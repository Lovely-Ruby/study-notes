<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="request.js"></script>
    <script src="spark-md5.min.js"></script>

    <style>
      body {
        width: 100vw;
        height: 100vh;
        padding: 0;
        margin: 0;
      }
      #uploadCube {
        margin-top: 10px;
        /* width: 520px; */
        overflow: hidden;
      }

      .cube {
        width: 50px;
        height: 50px;
        background-color: #fff;
        float: left;
        border: 1px solid rgb(0, 0, 0);
        font-size: 12px;
        .progress {
          height: 100%;
          line-height: 50px;
          text-align: center;
        }
        .uploading {
          background-color: #409eff;
        }
        .success {
          background-color: #51f400;
        }
        .error {
          background-color: #ff9090;
        }
      }
      #hashProgressBox {
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <div>
      <span>请选择 hash 计算方式：</span>
      <select name="hashMethod" id="hashMethod">
        <option value="0">主线程</option>
        <option value="1">工作者线程</option>
        <option value="2">fiber</option>
      </select>
    </div>
    <div style="margin: 20px 0">
      <span>UI 卡顿测试, 计算 hash 的时候输入内容, 观察是否卡顿：</span>
      <div id="textContent "></div>
    </div>
    <input type="file" id="file" />
    <button id="uploadButton">点击上传</button>
    <button id="pauseButton">暂停</button>
    <button id="resumeButton">继续</button>
    <!-- <button id="mergeButton">点击合并</button> -->
    <div id="hashProgressBox">
      计算 hash 进度： <progress value="0" id="hashProgress" max="100"></progress>
      <span id="hashProgressSpan"></span>
    </div>
    <div>上传进度图：</div>
    <div id="uploadCube">
      <!-- <div class="cube">
        <div class="progress success" style="width: 100%">100%</div>
      </div>
      <div class="cube">
        <div class="progress success" style="width: 100%">100%</div>
      </div>
      <div class="cube">
        <div class="progress success" style="width: 100%">100%</div>
      </div>
      <div class="cube">
        <div class="progress uploading" style="width: 100%">100%</div>
      </div> -->
    </div>
  </body>

  <script>
    // 工具脚本
    function hiddenButton(id) {
      document.getElementById(id).setAttribute('style', 'display: none');
    }
    function displayButotn(id) {
      document.getElementById(id).setAttribute('style', 'display: inline-block');
    }
    /**
     * 默认切片大小
     */
    const SIZE = 1 * 1024 * 1024;

    /**
     * 功能：生成切片
     */
    function handleCreateChunk(file, size = SIZE) {
      const fileChunkList = [];
      progressData = [];
      let cur = 0;
      while (cur < file.size) {
        fileChunkList.push({
          file: file.slice(cur, cur + size),
        });
        progressData.push({ percentage: 0 });
        cur += size;
      }
      return fileChunkList;
    }

    /**
     * 功能：生成页面进度的 HTML
     */
    function handleUpdateHTML(progressData) {
      let uploadCube = document.querySelector('#uploadCube');
      let html = '';
      progressData.forEach((item) => {
        const { percentage } = item;
        let className = '';
        if (percentage < 100) {
          className = 'progress uploading';
        } else if (percentage == 100) {
          className = 'progress success';
        }
        html += ` <div class="cube">
      <div class="${className}" style="width: ${percentage}%">${percentage}%</div>
    </div>`;
      });
      uploadCube.innerHTML = html;
    }

    /**
     * 功能：处理每个 chunk 的 xhr.upload.onprogress，拿到各个 chunk 的上传进度
     * - 1. 同时通过 handleUpdateHTML 更新进度页面
     * - 2. progressData 用来记录各个 chunk 的进度
     */
    let progressData = [];
    function handleCreateOnProgress(data) {
      return (e) => {
        data.percentage = Number(((e.loaded / e.total) * 100).toFixed(2));
        // console.log(JSON.stringify(progressData));
        handleUpdateHTML(progressData);
      };
    }

    /**
     * xhrList 用来存放已经上传的对象
     */
    const xhrList = [];
    /**
     * 功能： 上传切片
     * - 注意 map 里别忘了写 return
     */
    async function uploadChunks(hanldleData, fileName, fileHash, hadUploadedChunksListMap) {
      // 上传的时候根据 hadUploadedChunksListMap 在刷一遍 progressData
      Object.keys(hadUploadedChunksListMap).forEach((key) => {
        progressData[key]['percentage'] = 100;
      });
      console.log(progressData);
      const requestList = hanldleData
        .filter(({ index }) => !hadUploadedChunksListMap[index])
        .map(({ chunk, index }) => {
          const formData = new FormData();
          formData.append('chunk', chunk);
          formData.append('index', index);
          formData.append('fileName', fileName);
          formData.append('fileHash', fileHash);
          return { formData, index };
        })
        .map(({ formData, index }) => {
          return request({
            url: 'upload',
            data: formData,
            onprogress: handleCreateOnProgress(progressData[index]),
            xhrList,
          });
        });
      await Promise.all(requestList).then((res) => {
        console.log('所有上传结束', res);
      });
      console.log('发送合并请求');
      request({
        url: 'merge',
        headers: {
          'content-type': 'application/json',
        },
        data: JSON.stringify({
          size: SIZE,
          fileHash,
          fileName,
        }),
      }).then((res) => {
        const { code } = JSON.parse(res.data);
        if (code === 1) {
          hiddenButton('pauseButton');
          displayButotn('uploadButton');
          alert('合并成功');
        }
      });
    }

    async function handleBlob2ArrayBuffer(blob) {
      return new Promise((resolve) => {
        const fileReader = new FileReader();
        fileReader.readAsArrayBuffer(blob);
        fileReader.onload = function (e) {
          resolve(e.target.result);
        };
      });
    }

    /**
     * 功能：工作者模式计算文件 Hash
     */
    function workerCalculateHash(fileChunkList) {
      console.time('worker calculate hash');
      return new Promise(async (resolve) => {
        let worker = new Worker('./hash.js');
        worker.postMessage(fileChunkList);
        worker.onmessage = function (e) {
          const { percentage } = e.data;
          document.querySelector('#hashProgress').value = percentage;
          document.querySelector('#hashProgressSpan').innerHTML = `${percentage.toFixed(2)} %`;
          if (e?.data?.hash) {
            resolve(e?.data?.hash);
            console.timeEnd('worker calculate hash');
          }
        };
        worker.onerror = function (e) {
          console.log(e);
        };
      });
    }

    /**
     * 功能：主线程计算文件 Hash
     */
    async function mainCalculateHash(fileChunkList) {
      console.time('main calculate hash');
      const data = fileChunkList;
      const spark = new SparkMD5.ArrayBuffer();
      let percentage = 0;
      for (let i = 0, len = data.length; i < len; i++) {
        const eachArrayBuffer = await handleBlob2ArrayBuffer(data[i].file);
        percentage += 100 / len;
        document.querySelector('#hashProgress').value = percentage;
        document.querySelector('#hashProgressSpan').innerHTML = `${percentage.toFixed(2)} %`;
        spark.append(eachArrayBuffer);
      }
      const hash = spark.end();
      console.timeEnd('main calculate hash');
      return hash;
    }

    /**
     * - 1. 这里不好用 for 循环，因为会被打断，所以for 里的步数也会丢失
     * - 2. 这里的 workLoop 循环也要 window.requestIdleCallback(workLoop); 调用一下自己
     * - 因为 deadLine.timeRemaining() > 0 可能不成立，while 也就跳出来了。
     * - 其实留给 while 执行的时间非常短，平均也就 2 ~ 6ms 左右，可以打印 deadLine.timeRemaining() 看一下
     * -
     */
    function fiberCalculateHash(fileChunkList) {
      console.time('fiber calculate hash');
      return new Promise((resolve) => {
        const data = fileChunkList;
        const len = fileChunkList.length;
        const spark = new SparkMD5.ArrayBuffer();
        let i = 0;
        let percentage = 0;
        const workLoop = async (deadLine) => {
          console.log('timeRemaining:>>', deadLine.timeRemaining());
          while (i < len && deadLine.timeRemaining() > 0) {
            const eachArrayBuffer = await handleBlob2ArrayBuffer(data[i].file);
            spark.append(eachArrayBuffer);
            i++;
            if (i < len) {
              percentage = Number(((i / len) * 100).toFixed(2));
            } else {
              percentage = 100;
              resolve(spark.end()); // resolve 不会像 return 一样阻断后面代码的执行
              console.timeEnd('fiber calculate hash');
            }
            document.querySelector('#hashProgress').value = percentage;
            document.querySelector('#hashProgressSpan').innerHTML = `${percentage.toFixed(2)} %`;
          }
          // 递归调用一下，因为我们的条件是 deadLine.timeRemaining() > 0，所以 while 会跳出来的
          if (i < len) {
            window.requestIdleCallback(workLoop);
          }
        };
        // 调用
        window.requestIdleCallback(workLoop);
      });
    }

    /**
     * 功能：计算整体文件 Hash
     */
    async function handleCalculateHash(fileChunkList) {
      switch (hashCalculateMethod) {
        case '0': {
          console.log('主线程 计算hash:');
          return await mainCalculateHash(fileChunkList);
          break;
        }
        case '1': {
          console.log('工作者线程 计算hash:');
          return await workerCalculateHash(fileChunkList);
          break;
        }
        case '2': {
          console.log('Fiber 计算hash:');
          return await fiberCalculateHash(fileChunkList);
          break;
        }
      }
    }

    /**
     * 功能：调用验证 hash 接口
     */
    function handleVerifyHash(fileHash, fileName) {
      return new Promise(async (resolve) => {
        const { data } = await request({
          url: 'verify',
          headers: {
            'content-type': 'application/json',
          },
          data: JSON.stringify({
            fileHash,
            fileName,
          }),
        });
        resolve(JSON.parse(data));
      });
    }

    /**
     * 功能：点击上传之后处理一下按钮的显示隐藏
     * - 以及把继续上传所需的变量放到 Options 里，避免把变量放到全局了。
     */

    function handleButton(option) {
      hiddenButton('uploadButton');
      displayButotn('pauseButton');
      /**
       * 功能：暂停按钮
       */
      document.getElementById('pauseButton').addEventListener('click', () => {
        xhrList.forEach((xhr) => xhr.abort());
        hiddenButton('pauseButton');
        displayButotn('resumeButton');
      });
      /**
       * 功能：继续按钮
       * - 调用验证端口 verify
       */
      document.getElementById('resumeButton').addEventListener('click', async () => {
        handleVerify(option);
        hiddenButton('resumeButton');
        displayButotn('pauseButton');
      });
    }

    /**
     * - 功能：处理验证 hash
     * - 页面刷新 => 上传 => 验证 => 返回服务器已上传的chunkList => 过滤
     * - 暂停 => 继续上传 => 验证 => 返回服务器已上传的chunkList => 过滤
     * - 后半部分的逻辑是一样的，所以功能合并
     */
    async function handleVerify(option) {
      const { fileHash, fileName, fileChunkList } = option;
      // 根据这个值把进度条修改一下
      const { code, message, hadUploadedChunksList } = await handleVerifyHash(fileHash, fileName);
      const hadUploadedChunksListMap = {};
      hadUploadedChunksList.forEach((item) => (hadUploadedChunksListMap[item.split('_')[1]] = true));
      if (code === 0 || code === 1) {
        const hanldleData = fileChunkList.map(({ file }, index) => {
          return {
            chunk: file,
            index,
          };
        });
        await uploadChunks(hanldleData, fileName, fileHash, hadUploadedChunksListMap);
      }
      if (code === 2) {
        hiddenButton('pauseButton');
        displayButotn('uploadButton');
        alert('文件已秒传');
      }
    }
  </script>

  <script>
    // 主逻辑
    (function () {
      hiddenButton('resumeButton');
      hiddenButton('pauseButton');
    })();

    let hashCalculateMethod = '0';
    document.getElementById('hashMethod').onchange = function (e) {
      hashCalculateMethod = e.target.value;
    };
    /**
     * - 功能：上传前先生成 hash ，然后调用验证接口
     */
    document.getElementById('uploadButton').onclick = async function () {
      progressData.length = 0;
      // 切片
      const file = document.getElementById('file').files[0];
      const fileName = file.name;
      const fileChunkList = handleCreateChunk(file);
      const fileHash = await handleCalculateHash(fileChunkList);
      const option = { fileName, fileChunkList, fileHash };
      handleButton(option);
      handleVerify(option);
    };
  </script>
</html>
